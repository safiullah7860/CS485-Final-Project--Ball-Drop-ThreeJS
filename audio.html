<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Three.js Cloth Rolling Down a Staircase</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.rawgit.com/mrdoob/three.js/r129/build/three.min.js"></script>
    <script src="https://cdn.rawgit.com/mrdoob/three.js/r129/examples/js/controls/OrbitControls.js"></script>

    <script>
      // Set up the scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xbfd1e5);
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(-5, 10, 10);
      const renderer = new THREE.WebGLRenderer();
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Add lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 0.5);
      pointLight.position.set(10, 10, 10);
      camera.add(pointLight);
      scene.add(camera);

      // Set up the cloth
      const clothWidth = 2;
      const clothHeight = 2;
      const clothSegments = 5;
      const clothGeometry = new THREE.PlaneGeometry(
        clothWidth,
        clothHeight,
        clothSegments,
        clothSegments
      );
      const clothTexture = new THREE.TextureLoader().load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/crate.gif"
      );
      const clothMaterial = new THREE.MeshPhongMaterial({
        map: clothTexture,
        side: THREE.DoubleSide,
      });
      const cloth = new THREE.Mesh(clothGeometry, clothMaterial);
      cloth.position.set(4, 10, 0);
      scene.add(cloth);

      // Set up the ground
      const groundTexture = new THREE.TextureLoader().load(
        "https://threejs.org/examples/textures/hardwood2_diffuse.jpg"
      );
      groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
      groundTexture.repeat.set(20, 20);
      const groundMaterial = new THREE.MeshPhongMaterial({
        map: groundTexture,
      });
      const groundGeometry = new THREE.PlaneGeometry(50, 50);
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -1;
      scene.add(ground);
      // Set up the staircase
      const stepWidth = 1;
      const stepHeight = 0.3;
      const stepDepth = 1;
      const numSteps = 20;
      const staircase = new THREE.Group();
      for (let i = 0; i < numSteps; i++) {
        const stepGeometry = new THREE.BoxGeometry(
          stepWidth,
          stepHeight,
          stepDepth
        );
        const stepTexture = new THREE.TextureLoader().load(
          "https://threejs.org/examples/textures/brick_diffuse.jpg"
        );
        const stepMaterial = new THREE.MeshPhongMaterial({
          color: 0x808080, // red color
          shininess: 50,
        });

        const step = new THREE.Mesh(stepGeometry, stepMaterial);
        step.position.x = (i - numSteps / 2) * stepWidth - 2; // Move the staircase to the left side of the scene
        step.position.y = -0.7 + (i * stepHeight + stepHeight / 2); // add offset of half stepHeight
        staircase.add(step);
      }
      scene.add(staircase);

      // Set up the physics
      const gravity = new THREE.Vector3(0, -9.81, 0);
      const mass = 1;
      const damping = 0.08;
      const clothParticles = clothGeometry.attributes.position.count;

      const clothConstraints = [];
      for (let i = 0; i < clothParticles; i++) {
        const x = i % (clothSegments + 1);
        const y = Math.floor(i / (clothSegments + 1));
        if (x < clothSegments && y < clothSegments) {
          clothConstraints.push([i, i + 1]);
          clothConstraints.push([i, i + clothSegments + 1]);
        }
      }
      const clothVelocities = [];
      for (let i = 0; i < clothParticles; i++) {
        clothVelocities.push(new THREE.Vector3(0, 0, 0));
      }

      // Animate the scene
      let lastTime = performance.now();
      function animate() {
        const time = performance.now();
        const deltaTime = (time - lastTime) / 500;

        // Apply forces to cloth particles
        const positions = clothGeometry.attributes.position;
        for (let i = 0; i < clothParticles; i++) {
          const vertex = new THREE.Vector3().fromBufferAttribute(positions, i);
          const velocity = clothVelocities[i];

          // Gravity
          const forceGravity = gravity.clone().multiplyScalar(mass);

          // Damping
          const forceDamping = velocity.clone().multiplyScalar(-damping);

          const force = forceGravity.add(forceDamping);
          velocity.add(force.multiplyScalar(deltaTime));
          vertex.add(velocity.multiplyScalar(deltaTime));

          positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }

        // Satisfy constraints
        for (let i = 0; i < clothConstraints.length; i++) {
          const constraint = clothConstraints[i];
          const p1 = new THREE.Vector3().fromBufferAttribute(
            positions,
            constraint[0]
          );
          const p2 = new THREE.Vector3().fromBufferAttribute(
            positions,
            constraint[1]
          );
          const distance = p1.distanceTo(p2);
          const direction = p2.clone().sub(p1).normalize();
          const correction = direction.multiplyScalar(0.5 * (distance - 1));
          p1.add(correction);
          p2.sub(correction);
          positions.setXYZ(constraint[0], p1.x, p1.y, p1.z);
          positions.setXYZ(constraint[1], p2.x, p2.y, p2.z);
        }
        clothGeometry.attributes.position.needsUpdate = true;

        lastTime = time;
        const windForce = new THREE.Vector3(-2, 0, 0).multiplyScalar(5);
        for (let i = 1; i < clothParticles; i++) {
          const velocity = clothVelocities[i];
          const force = windForce.clone().sub(velocity).multiplyScalar(damping);
          velocity.add(force);
          positions.setXYZ(
            i,
            positions.getX(i) + velocity.x * deltaTime,
            positions.getY(i) + velocity.y * deltaTime,
            positions.getZ(i) + velocity.z * deltaTime
          );
        }
        // Render the scene
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>
